#!/usr/bin/env python3
# to get GWeather logging, run with
# `G_MESSAGES_DEBUG=GWeather`
import argparse
import code
import gi
import logging

gi.require_version('GWeather', '4.0')

from gi.repository import GLib
from gi.repository import GWeather

logger = logging.getLogger(__name__)

class WeatherSource:
    '''
    this class abstracts operations which would query a remote weather server
    '''
    def __init__(self):
        self.info = GWeather.Info()
        self.info.set_application_id('org.uninsane.sane-weather')
        self.info.set_contact_info('contact@uninsane.org')
        self.world = GWeather.Location.get_world()

    def query_loc(self, loc: GWeather.Location) -> None:
        '''
        query the weather for some location, asynchronously.
        after calling, poll the `try_...` methods to check for results.
        '''
        logger.debug(f"querying: {loc.get_coords()}")
        self.info.set_location(loc)
        self.info.update()

    def try_get_celcius(self) -> float | None:
        valid, temp = self.info.get_value_temp(GWeather.TemperatureUnit.CENTIGRADE)
        logger.debug(f"try_get_celcius: valid={valid}, temp={temp}")
        if not valid: temp = None

        return temp

class QueryOp:
    def __init__(self, loc: GWeather.Location):
        self.loc = loc

class PrintTempOp:
    pass

class DiagnosticsOp:
    pass

class ExitOp:
    pass

class TopLevel:
    """
    this class acts as the "event loop" which glib apps expect.
    caller sets up a "work queue" of everything they want to do, then calls `run`.
    glib calls `poll` in a loop, and each time we try to work through another item in the work_queue.
    when the work_queue is empty, exit glib's main loop & return to the caller (from `run`).
    """
    def __init__(self):
        self._loop = GLib.MainLoop()
        self.source = WeatherSource()
        self.work_queue = []

    def enqueue(self, op) -> None:
        self.work_queue.append(op)

    def run(self) -> None:
        self.enqueue(ExitOp())
        GLib.idle_add(self.poll)
        self._loop.run()

    def poll(self) -> bool:
        work = self.work_queue[0]
        if isinstance(work, QueryOp):
            del self.work_queue[0]
            self.source.query_loc(work.loc)
        elif isinstance(work, PrintTempOp):
            temp = self.source.try_get_celcius()
            if temp is not None:
                del self.work_queue[0]
                print(f"{int(temp)} C")
        elif isinstance(work, DiagnosticsOp):
            del self.work_queue[0]
            # GWeather does transparent caching so that we don't usually hit the web
            last_update = self.source.info.get_update()
            logger.debug(f"last update: {last_update}")
        elif isinstance(work, ExitOp):
            logger.debug("quitting GLib MainLoop")
            self.source.info.store_cache()
            self._loop.quit()
        else:
            assert False, f"unknown work: {work}"

        return True  # re-queue this idle fn


def main():
    logging.basicConfig()

    parser = argparse.ArgumentParser(description="acquire weather information for user display")
    parser.add_argument(
        '--station-code',
        default='KSEA',
        help='4-letter METAR weather station code for where we want to know weather\n '
             'to find your station see here: <https://aviationweather.gov/metar>'
    )
    parser.add_argument('--break-before', action='store_true', help='drop into a REPL before do anything (for debugging)')
    parser.add_argument('--break-after', action='store_true', help='drop into a REPL after completing the work (for debugging)')
    parser.add_argument('--verbose', action='store_true', help='enable verbose logging')

    args = parser.parse_args()

    if args.verbose:
        logger.setLevel(logging.DEBUG)
        GLib.log_set_debug_enabled(True)

    toplevel = TopLevel()
    here = GWeather.Location.find_by_station_code(toplevel.source.world, args.station_code)

    if args.break_before:
        code.interact(local=dict(**globals(), **locals()))

    toplevel.enqueue(QueryOp(here))
    toplevel.enqueue(PrintTempOp())
    toplevel.enqueue(DiagnosticsOp())
    toplevel.run()

    if args.break_after:
        code.interact(local=dict(**globals(), **locals()))


if __name__ == '__main__':
    main()
